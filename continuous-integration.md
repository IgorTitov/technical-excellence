# Непрерывная интеграция / Continuous Integration

| Источник | Статус |
| - | - |
| [Ссылка](https://less.works/ru/less/technical-excellence/continuous-integration.html) | *В работе* |

## Содержание

- [Введение](#Введение)
- [Практики непрерывной интеграции](#Практики-непрерывной-интеграции)
- [Заключение](#Заключение)
- [Полезные ссылки](#Полезные-ссылки)
- [Сноски](#Сноски)

## Введение

> Использование COBOL калечит разум; исходя из этого, обучение этому языку должно быть признано уголовно наказуемым
> преступлением.
> --Эдсгер Дейкстра

Непрерывная интеграция (CI) является основой для масштабирования бережливой и гибкого разработки ПО:

> Мы пришли к выводу, что нет никаких причин, по которым процессы непрерывной интеграции и автоматической сборки не будут
> масштабироваться на команды любого размера. На самом деле ... [они] становятся более важными, чем когда-либо.
> [Magennis07](http://blog.aspiring-technology.com/file.axd?file=Continuous+Integration+at+Enterprise+Scale.pdf)

С помощью CI разработчики постепенно развивают стабильную систему, работая небольшими порциями и короткими циклами. Это
позволяет командам работать над общим кодом, улучшает его качество и повышает прозрачность разработки.

Существует неправильное представление о CI; это кажется простой концепцией, но на практике это не так. Попробуем избавиться
от одного из частых заблуждений: *Непрерывная Интеграция это не автоматизация сборки или запуск тестов*.

[Классическая статья о **CI**](https://martinfowler.com/articles/continuousIntegration.html) постулирует:

> Непрерывная интеграция ― это практика разработки программного обеспечения, в которой участники команды часто выполняют
> интеграцию своих изменений. Как правило, каждый участник выполняет интеграцию как минимум раз в день, и в итоге
> достигается такой режим работы, при котором интеграция выполняется несколько раз в день. Каждая интеграция проверяется
> путем автоматической сборки (включающей тестирование), что позволяет находить ошибки интеграции как можно скорее.

## Практики непрерывной интеграции

Непрерывная интеграция...

- это практика разработки...
- сохраняет работоспособность системы
- приветствует небольшие изменения
- способствует "выращиванию" системы
- проводится по крайней мере ежедневно
- сохраняет основную ветку в рабочем состоянии
- поддерживается CI-системами
- поддерживается большим количеством автоматических тестов

### Практика разработки

Слишком часто дискуссии о CI касаются инструментов автоматизации. Хотя CI по сути является практикой разработки. Оуэн
Роджерс, один из первых создателей CruiseControl.NET<sup>1</sup>, пишет:

> Непрерывная интеграция - это практика, и речь идет о том, что люди делают, а не о том, какие инструменты они используют.
> Когда проект начинает масштабироваться, легко попасть в ловушку, думая, что команда практикует непрерывную интеграцию
> только потому, что все инструменты настроены и работают. Если разработчики не взяли себе за правило регулярной интегрировать
> свои изменения или поддерживать интеграционную среду в рабочем состоянии, то они не практикуют непрерывную интеграцию.
> И точка. [[Rogers04](https://link.springer.com/chapter/10.1007%2F978-3-540-24853-8_8)]

Разбиение изменений в коде на небольшие порции, их интеграция, не менее 1 раза в день, и не ломающаяся сборка - все это
выполняется каждым разработчиком. Для этого нужен навык работы с небольшими приращениями и постоянной синхронизацией своей
собственной копии системы (или ее части) с общей версии.

Внедрение CI требует изменения *поведения людей*. Мы работали в несколькими крупных продуктах с отлично автоматизированной
сборкой, но разработчики не часто интегрировали свой код. Хуже того, культура "не ломайте сборку" активно насаждалась, и в
том числе через позор людей, сломавших сборку. Как вы думаете, к какому результату это привело? Разработчики стали
откладывать интеграции из-за страха что-то сломать. Несмотря на их превосходную *всегда зеленую* (всегда проходящую)
автоматизированную сборку, они делают вещи, прямо противоположные практике CI.

Помогает разработка через тестирование (TDD) с постоянным рефакторингом. Когда разработчик тестирует свой код модульным
тестом, он гарантирует, что его локальная копия всегда работает. Все тесты должны проходить все время. Теоретически он может
интегрировать общий код каждый цикл TDD (около десяти минут<sup>2</sup>), но на практике достаточно это делать после пары
циклов.

CI для больших продуктов сложен именно потому, что это практика разработки. Если бы речь шла только об инструментах
автоматизации, вы могли бы просто начать проект по внедрению CI или нанять другую компанию для этой работы. Но как практика
разработки, CI требует изменения в повседневных привычках всех разработчиков. Для многих людей это сложно, требует времени и
постоянных тренировок.

При наличии правильных привычках, разработчики будут...

## Держать систему в рабочем состоянии

По аналогии с
[концептом бережливого производства - **Дзидока(jidoka)**](https://less.works/ru/less/principles/lean-thinking.html), CI
подразумевает всегда держать систему в рабочем состоянии. Если тест не пройден, при локальном прогоне или в CI-инструменте,
разработчик исправляет его немедленно и, следовательно, всегда сохраняет систему в рабочем состоянии.

![continuous-integration-chicken.png](https://less.works/img/technical-excellence/xcontinuous-integration-chicken.png.pagespeed.ic.SJsJ6WAhX_.webp)

Традиционный последовательный процесс разработки постоянно имеет дезинтегрированную незавершенную работу (work in progress,
WIP). Никто не знает, работают ли эти части системы вместе и есть ли дефекты. WIP затрудняет прогнозирование того, когда
система может быть готова. CI повышает прозрачность, устраняя этот WIP, всегда сохраняя интегрированным все части между
собой и обеспечивая контроль и предсказуемость процесса.

## Заключение

## Полезные ссылки

## Сноски

1. [CruiseControl.NET](http://cruisecontrol.sourceforge.net/) - это CI-сервер для платформы for Microsoft .NET.
2. Для разработки на Java 10 минут - это слишком много. Для C++ в среднем нормально. Для C, возможно даже мало. 10 минут -
среднее время TDD-цикла независимо от языка и платформы.